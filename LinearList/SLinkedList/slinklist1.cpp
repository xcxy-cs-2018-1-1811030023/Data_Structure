/*
    静态链表：分配一片连续的内存空间（数组），各个结点集中安置在这个空间的某个位置。每个结点有两部分组成，一为数据元素，二为下个结点的数组下标（游标）
    相对于单链表，下标为0的结点相当于"头结点"，游标相当于指针，游标为几就代表下一个结点存放在数组下标为几的单元中（数组下标为物理上的顺序，而位序为逻辑上的顺序），游标为-1表示已经达到表尾。
    */
静态链表的定义：
#define MaxSize 10              //静态链表的最大长度
typedef struct{                 //静态链表结构类型的定义
    ElemType data;              //储存数据元素
    int next;                   //下一个元素的数组下标
}SLinkList[MaxSize];

现阶段对于静态链表的考察不多，但我们要清楚其代码的工作原理
静态链表优点：增，删操作不需要大量移动元素，缺点；不能随机存取，只能从头结点开始依次往后查找，固定了内存空间容量之后就不可改变了。
功能实现原理：
1.初始化：
把a[0]的next设置为-1，使其不指向任何一个元素，其实内存中的任何一个地方肯定都会有数据，只不过是脏数据而已，为了让计算机识别出，哪些结点是脏数据
我们应该在初始化的时候把结点next值设置为特殊的值，当使用时，只需要判断这个特殊的值，就晓得这个结点是不是空闲的，就可以用这个结点来存放新的数据元素。
2.查找某个位序的结点
通过游标记录的线索依次往后寻找后一个结点，直到找到我们想要的那个结点为止，从头结点出发挨个往后遍历结点，时间复杂度为O(n)
3.插入位序为i的结点
a.首先找到一个空的结点，存入数据元素，b.从头结点出发找到位序为i-1的结点，c.修改新结点的next，d.修改i-1号结点的next
适用场景：1.不支持指针的低级语言；2.数据元素数量固定不变的场景（如操作系统的文件分配表FAT）
4.删除某个结点：
a.从头结点出发找到前驱结点，b.修改前驱结点的游标，c.被删除结点next设置为表示空闲的特殊值