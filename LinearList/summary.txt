对比顺序表和链表：
了解一个数据结构的时候，要关注数据结构的三要素：
1.逻辑结构：
都是属于线性表，都是线性结构
2.物理结构/存储结构：
顺序表：
采用顺序存储，只需要知道顺序表的起始地址，我们就可以立即找到第i个元素的地址即有随机存储性
各个结点只需存储数据元素，不需要存储其他冗余信息。
优点：支持随机存储，存储密度高
缺点：大片连续空间分配不方便，改变容量不方便

链表：
采用链式存储，当我们要找到第i个结点的时候，我们只能从第一个结点按个往后的寻找即不可随机存取
各个结点不只是要存储数据元素，还要存储指针，所以存储密度低
优点：离散的小空间分配方便，改变容量方便
缺点：不可随机存取，存储密度低
所以：显然各有千秋，相互互补

3.数据的运算/基本操作：
从"创销，增删改查"基本开始
创：
顺序表：需要预分配大片连续空间。若分配空间过小，则之后不方便扩展容量，若分配空间过大，则浪费内存资源。
        静态分配：静态数组（容量不可改变）
        动态分配：动态数组（malloc,free,）容量可以改变，但需要移动大量元素，时间代价高
链表：只需要分配一个头结点（也可以不要头结点，只声明一个头指针），之后方便扩展。
所以：关于存储空间的灵活性，链表更胜一筹

销：
顺序表：静态分配：静态数组，只需修改Length=0(逻辑上标记为空表)，当定义的数组生命周期结束后，系统自动回收空间（即不需要自己管的）
        动态分配：先修改Length，需要手动free(用malloc申请的空间是存储在堆区的，需要用free来销毁，所以malloc和free是成对出现的)
链表：使用循环依次删除各个结点（使用free函数)

增、删：
顺序表：插入/删除元素要将后续元素都后移/前移，时间复杂度O(n),时间开销主要来自移动元素。如果数据元素很大，则移动的时间代价很高。
链表：插入/删除元素只需要修改指针即可。时间复杂度O(n)，时间开销主要来自查找目标元素。查找元素的时间代价更低。
所以：链表效率更高一些

查：
顺序表：按位查找，因为具有随机存储，时间复杂度为O(1)。按值查找：为O(n)，如果表内元素有序，可在O(log2n)时间内找到
链表：按位查找和按值查找都只能从第一个元素开始往后遍历，时间复杂度为O(n)。
所以：顺序表查找的效率要高的多

使用范围：
1.表长难以预估、经常要增加/删除元素，使用链表
2.表长可以预估、查询（搜索）操作较多，使用顺序表